C251 COMPILER V5.60.0,  SEEKFREE_FUNCTION                                                  15/07/24  23:30:46  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE SEEKFREE_FUNCTION
OBJECT MODULE PLACED IN .\Out_File\SEEKFREE_FUNCTION.obj
COMPILER INVOKED BY: D:\c51-keil\C251\BIN\C251.EXE ..\..\Libraries\seekfree_peripheral\SEEKFREE_FUNCTION.c XSMALL WARNIN
                    -GLEVEL(3) OPTIMIZE(0,SPEED) BROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\s
                    -eekfree_peripheral;..\CODE;..\USER\inc;..\USER\src;..\..\Libraries\seekfree_components;.\Out_File) DEBUG PRINT(.\Out_Fil
                    -e\SEEKFREE_FUNCTION.lst) TABS(2) OBJECT(.\Out_File\SEEKFREE_FUNCTION.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * CH32V307VCT6 Opensourec Library ¼´£¨CH32V307VCT6 ¿ªÔ´¿â£©ÊÇÒ»¸ö»ùÓÚ¹Ù·½ SDK ½Ó¿ÚµÄµÚÈı·½¿ªÔ´¿â
    3          * Copyright (c) 2022 SEEKFREE Öğ·É¿Æ¼¼
    4          *
    5          * ±¾ÎÄ¼şÊÇCH32V307VCT6 ¿ªÔ´¿âµÄÒ»²¿·Ö
    6          *
    7          * CH32V307VCT6 ¿ªÔ´¿â ÊÇÃâ·ÑÈí¼ş
    8          * Äú¿ÉÒÔ¸ù¾İ×ÔÓÉÈí¼ş»ù½ğ»á·¢²¼µÄ GPL£¨GNU General Public License£¬¼´ GNUÍ¨ÓÃ¹«¹²Ğí¿ÉÖ¤£©µÄÌõ¿î
    9          * ¼´ GPL µÄµÚ3°æ£¨¼´ GPL3.0£©»ò£¨ÄúÑ¡ÔñµÄ£©ÈÎºÎºóÀ´µÄ°æ±¾£¬ÖØĞÂ·¢²¼ºÍ/»òĞŞ¸ÄËü
   10          *
   11          * ±¾¿ªÔ´¿âµÄ·¢²¼ÊÇÏ£ÍûËüÄÜ·¢»Ó×÷ÓÃ£¬µ«²¢Î´¶ÔÆä×÷ÈÎºÎµÄ±£Ö¤
   12          * ÉõÖÁÃ»ÓĞÒşº¬µÄÊÊÏúĞÔ»òÊÊºÏÌØ¶¨ÓÃÍ¾µÄ±£Ö¤
   13          * ¸ü¶àÏ¸½ÚÇë²Î¼û GPL
   14          *
   15          * ÄúÓ¦¸ÃÔÚÊÕµ½±¾¿ªÔ´¿âµÄÍ¬Ê±ÊÕµ½Ò»·İ GPL µÄ¸±±¾
   16          * Èç¹ûÃ»ÓĞ£¬Çë²ÎÔÄ<https://www.gnu.org/licenses/>
   17          *
   18          * ¶îÍâ×¢Ã÷£º
   19          * ±¾¿ªÔ´¿âÊ¹ÓÃ GPL3.0 ¿ªÔ´Ğí¿ÉÖ¤Ğ­Òé ÒÔÉÏĞí¿ÉÉêÃ÷ÎªÒëÎÄ°æ±¾
   20          * Ğí¿ÉÉêÃ÷Ó¢ÎÄ°æÔÚ libraries/doc ÎÄ¼ş¼ĞÏÂµÄ GPL3_permission_statement.txt ÎÄ¼şÖĞ
   21          * Ğí¿ÉÖ¤¸±±¾ÔÚ libraries ÎÄ¼ş¼ĞÏÂ ¼´¸ÃÎÄ¼ş¼ĞÏÂµÄ LICENSE ÎÄ¼ş
   22          * »¶Ó­¸÷Î»Ê¹ÓÃ²¢´«²¥±¾³ÌĞò µ«ĞŞ¸ÄÄÚÈİÊ±±ØĞë±£ÁôÖğ·É¿Æ¼¼µÄ°æÈ¨ÉùÃ÷£¨¼´±¾ÉùÃ÷£©
   23          *
   24          * ÎÄ¼şÃû³Æ          zf_common_function
   25          * ¹«Ë¾Ãû³Æ          ³É¶¼Öğ·É¿Æ¼¼ÓĞÏŞ¹«Ë¾
   26          * °æ±¾ĞÅÏ¢          ²é¿´ libraries/doc ÎÄ¼ş¼ĞÄÚ version ÎÄ¼ş °æ±¾ËµÃ÷
   27          * ¿ª·¢»·¾³          MounRiver Studio V1.8.1
   28          * ÊÊÓÃÆ½Ì¨          CH32V307VCT6
   29          * µêÆÌÁ´½Ó          https://seekfree.taobao.com/
   30          *
   31          * ĞŞ¸Ä¼ÇÂ¼
   32          * ÈÕÆÚ                                      ×÷Õß                             ±¸×¢
   33          * 2022-09-15        ´óW            first version
   34          *********************************************************************************************************
             -***********/
   35          
   36          
   37          #include <stdarg.h>
   38          #include <string.h>
   39          
   40          #include "SEEKFREE_FUNCTION.h"
   41          
   42          //-------------------------------------------------------------------------------------------------------
             -------------
   43          // º¯Êı¼ò½é     »ñÈ¡ÕûĞÍÊıµÄ×î´ó¹«Ô¼Êı ¾ÅÕÂËãÊõÖ®¸üÏà¼õËğÊõ
   44          // ²ÎÊıËµÃ÷     num1            Êı×Ö1
   45          // ²ÎÊıËµÃ÷     num2            Êı×Ö2
   46          // ·µ»Ø²ÎÊı     uint32          ×î´ó¹«Ô¼Êı
   47          // Ê¹ÓÃÊ¾Àı     return func_get_greatest_common_divisor(144, 36);               // »ñÈ¡ 144 Óë 36 µÄ×î´ó¹
             -«Ô¼Êı
   48          // ±¸×¢ĞÅÏ¢     
   49          //-------------------------------------------------------------------------------------------------------
             -------------
   50          uint32 func_get_greatest_common_divisor (uint32 num1, uint32 num2)
   51          {
C251 COMPILER V5.60.0,  SEEKFREE_FUNCTION                                                  15/07/24  23:30:46  PAGE 2   

   52   1          while(num1 != num2)
   53   1          {
   54   2              if(num1 > num2)
   55   2              {
   56   3                  num1 = num1 - num2;
   57   3              }
   58   2              if(num1 < num2)
   59   2              {
   60   3                  num2 = num2 - num1;
   61   3              }
   62   2          }
   63   1          return num1;
   64   1      }
   65          
   66          //-------------------------------------------------------------------------------------------------------
             -------------
   67          // º¯Êı¼ò½é     Èí¼şÑÓÊ±
   68          // ²ÎÊıËµÃ÷     t               ÑÓÊ±Ê±¼ä
   69          // ·µ»Ø²ÎÊı     void
   70          // Ê¹ÓÃÊ¾Àı     func_soft_delay(100);
   71          // ±¸×¢ĞÅÏ¢     
   72          //-------------------------------------------------------------------------------------------------------
             -------------
   73          void func_soft_delay (volatile long t)
   74          {
   75   1          while(t --);
   76   1      }
   77          
   78          //-------------------------------------------------------------------------------------------------------
             -------------
   79          // º¯Êı¼ò½é     ×Ö·û´®×ªÕûĞÎÊı×Ö Êı¾İ·¶Î§ÊÇ [-32768,32767]
   80          // ²ÎÊıËµÃ÷     *str            ´«Èë×Ö·û´® ¿É´ø·ûºÅ
   81          // ·µ»Ø²ÎÊı     int32           ×ª»»ºóµÄÊı¾İ          
   82          // Ê¹ÓÃÊ¾Àı     int32 dat = func_str_to_int("-100");
   83          // ±¸×¢ĞÅÏ¢     
   84          //-------------------------------------------------------------------------------------------------------
             -------------
   85          int32 func_str_to_int (char *str)
   86          {
   87   1      
   88   1          uint8 sign = 0;                                                             // ±ê¼Ç·ûºÅ 0-ÕıÊı 1-¸ºÊı
   89   1          int32 temp = 0;                                                             // ÁÙÊ±¼ÆËã±äÁ¿
   90   1          do
   91   1          {
   92   2              if(NULL == str)
   93   2              {
   94   3                  break;
   95   3              }
   96   2      
   97   2              if('-' == *str)                                                         // Èç¹ûµÚÒ»¸ö×Ö·ûÊÇ¸ººÅ
   98   2              {
   99   3                  sign = 1;                                                           // ±ê¼Ç¸ºÊı
  100   3                  str ++;
  101   3              }
  102   2              else if('+' == *str)                                                    // Èç¹ûµÚÒ»¸ö×Ö·ûÊÇÕıºÅ
  103   2              {
  104   3                  str ++;
  105   3              }
  106   2      
  107   2              while(('0' <= *str) && ('9' >= *str))                                   // È·¶¨ÕâÊÇ¸öÊı×Ö
  108   2              {
  109   3                  temp = temp * 10 + ((uint8)(*str) - 0x30);                          // ¼ÆËãÊıÖµ
  110   3                  str ++;
  111   3              }
  112   2      
  113   2              if(sign)
C251 COMPILER V5.60.0,  SEEKFREE_FUNCTION                                                  15/07/24  23:30:46  PAGE 3   

  114   2              {
  115   3                  temp = -temp;
  116   3              }
  117   2          }while(0);
  118   1          return temp;
  119   1      }
  120          
  121          //-------------------------------------------------------------------------------------------------------
             -------------
  122          // º¯Êı¼ò½é     ÕûĞÎÊı×Ö×ª×Ö·û´® Êı¾İ·¶Î§ÊÇ [-32768,32767]
  123          // ²ÎÊıËµÃ÷     *str            ×Ö·û´®Ö¸Õë
  124          // ²ÎÊıËµÃ÷     number          ´«ÈëµÄÊı¾İ
  125          // ·µ»Ø²ÎÊı     void
  126          // Ê¹ÓÃÊ¾Àı     func_int_to_str(data_buffer, -300);
  127          // ±¸×¢ĞÅÏ¢     
  128          //-------------------------------------------------------------------------------------------------------
             -------------
  129          void func_int_to_str (char *str, int32 number)
  130          {
  131   1          uint8 data_temp[16];                                                        // »º³åÇø
  132   1          uint8 dat_bit = 0;                                                              // Êı×ÖÎ»Êı
  133   1          int32 number_temp = 0;
  134   1      
  135   1          do
  136   1          {
  137   2              if(NULL == str)
  138   2              {
  139   3                  break;
  140   3              }
  141   2      
  142   2              if(0 > number)                                                          // ¸ºÊı
  143   2              {
  144   3                  *str ++ = '-';
  145   3                  number = -number;
  146   3              }
  147   2              else if(0 == number)                                                    // »òÕßÕâÊÇ¸ö 0
  148   2              {
  149   3                  *str = '0';
  150   3                  break;
  151   3              }
  152   2      
  153   2              while(0 != number)                                                      // Ñ­»·Ö±µ½ÊıÖµ¹éÁã
  154   2              {
  155   3                  number_temp = number % 10;
  156   3                  data_temp[dat_bit ++] = func_abs(number_temp);                          // µ¹Ğò½«ÊıÖµÌáÈ¡³öÀ´
  157   3                  number /= 10;                                                       // Ï÷¼õ±»ÌáÈ¡µÄ¸öÎ»Êı
  158   3              }
  159   2              while(0 != dat_bit)                                                         // ÌáÈ¡µÄÊı×Ö¸öÊıµİ¼õ
             -´¦Àí
  160   2              {
  161   3                  *str ++ = (data_temp[dat_bit - 1] + 0x30);                              // ½«Êı×Ö´Óµ¹ĞòÊı×éÖĞ
             -µ¹ĞòÈ¡³ö ±ä³ÉÕıĞò·ÅÈë×Ö·û´®
  162   3                  dat_bit --;
  163   3              }
  164   2          }while(0);
  165   1      }
  166          
  167          //-------------------------------------------------------------------------------------------------------
             -------------
  168          // º¯Êı¼ò½é     ×Ö·û´®×ªÕûĞÎÊı×Ö Êı¾İ·¶Î§ÊÇ [0,65535]
  169          // ²ÎÊıËµÃ÷     *str            ´«Èë×Ö·û´® ÎŞ·ûºÅ
  170          // ·µ»Ø²ÎÊı     uint32          ×ª»»ºóµÄÊı¾İ          
  171          // Ê¹ÓÃÊ¾Àı     uint32 dat = func_str_to_uint("100");
  172          // ±¸×¢ĞÅÏ¢     
  173          //-------------------------------------------------------------------------------------------------------
             -------------
C251 COMPILER V5.60.0,  SEEKFREE_FUNCTION                                                  15/07/24  23:30:46  PAGE 4   

  174          uint32 func_str_to_uint (char *str)
  175          {
  176   1          uint32 temp = 0;                                                            // ÁÙÊ±¼ÆËã±äÁ¿
  177   1      
  178   1          do
  179   1          {
  180   2              if(NULL == str)
  181   2              {
  182   3                  break;
  183   3              }
  184   2      
  185   2              while(('0' <= *str) && ('9' >= *str))                                  // È·¶¨ÕâÊÇ¸öÊı×Ö
  186   2              {
  187   3                  temp = temp * 10 + ((uint8)(*str) - 0x30);                         // ¼ÆËãÊıÖµ
  188   3                  str ++;
  189   3              }
  190   2          }while(0);
  191   1      
  192   1          return temp;
  193   1      }
  194          
  195          //-------------------------------------------------------------------------------------------------------
             -------------
  196          // º¯Êı¼ò½é     ÕûĞÎÊı×Ö×ª×Ö·û´® Êı¾İ·¶Î§ÊÇ [0,65535]
  197          // ²ÎÊıËµÃ÷     *str            ×Ö·û´®Ö¸Õë
  198          // ²ÎÊıËµÃ÷     number          ´«ÈëµÄÊı¾İ
  199          // ·µ»Ø²ÎÊı     void
  200          // Ê¹ÓÃÊ¾Àı     func_uint_to_str(data_buffer, 300);
  201          // ±¸×¢ĞÅÏ¢     
  202          //-------------------------------------------------------------------------------------------------------
             -------------
  203          void func_uint_to_str (char *str, uint32 number)
  204          {
  205   1      
  206   1          int8 data_temp[16];                                                         // »º³åÇø
  207   1          uint8 dat_bit = 0;                                                              // Êı×ÖÎ»Êı
  208   1      
  209   1          do
  210   1          {
  211   2              if(NULL == str)
  212   2              {
  213   3                  break;
  214   3              }
  215   2      
  216   2              if(0 == number)                                                         // ÕâÊÇ¸ö 0
  217   2              {
  218   3                  *str = '0';
  219   3                  break;
  220   3              }
  221   2      
  222   2              while(0 != number)                                                      // Ñ­»·Ö±µ½ÊıÖµ¹éÁã
  223   2              {
  224   3                  data_temp[dat_bit ++] = (number % 10);                                  // µ¹Ğò½«ÊıÖµÌáÈ¡³öÀ´
  225   3                  number /= 10;                                                       // Ï÷¼õ±»ÌáÈ¡µÄ¸öÎ»Êı
  226   3              }
  227   2              while(0 != dat_bit)                                                         // ÌáÈ¡µÄÊı×Ö¸öÊıµİ¼õ
             -´¦Àí
  228   2              {
  229   3                  *str ++ = (data_temp[dat_bit - 1] + 0x30);                              // ½«Êı×Ö´Óµ¹ĞòÊı×éÖĞ
             -µ¹ĞòÈ¡³ö ±ä³ÉÕıĞò·ÅÈë×Ö·û´®
  230   3                  dat_bit --;
  231   3              }
  232   2          }while(0);
  233   1      }
  234          
  235          //-------------------------------------------------------------------------------------------------------
C251 COMPILER V5.60.0,  SEEKFREE_FUNCTION                                                  15/07/24  23:30:46  PAGE 5   

             -------------
  236          // º¯Êı¼ò½é     ×Ö·û´®×ª¸¡µãÊı ÓĞĞ§ÀÛ¼Æ¾«¶ÈÎªĞ¡ÊıµãºóÁùÎ»
  237          // ²ÎÊıËµÃ÷     *str            ´«Èë×Ö·û´® ¿É´ø·ûºÅ
  238          // ·µ»Ø²ÎÊı     float           ×ª»»ºóµÄÊı¾İ          
  239          // Ê¹ÓÃÊ¾Àı     float dat = func_str_to_float("-100.2");
  240          // ±¸×¢ĞÅÏ¢     
  241          //-------------------------------------------------------------------------------------------------------
             -------------
  242          float func_str_to_float (char *str)
  243          {
  244   1          uint8 sign = 0;                                                             // ±ê¼Ç·ûºÅ 0-ÕıÊı 1-¸ºÊı
  245   1          float temp = 0.0;                                                           // ÁÙÊ±¼ÆËã±äÁ¿ ÕûÊı²¿·Ö
  246   1          float temp_point = 0.0;                                                     // ÁÙÊ±¼ÆËã±äÁ¿ Ğ¡Êı²¿·Ö
  247   1          float point_bit = 1;                                                        // Ğ¡ÊıÀÛ¼Æ³ıÊı
  248   1      
  249   1          do
  250   1          {
  251   2              if(NULL == str)
  252   2              {
  253   3                  break;
  254   3              }
  255   2      
  256   2              if('-' == *str)                                                         // ¸ºÊı
  257   2              {
  258   3                  sign = 1;                                                           // ±ê¼Ç¸ºÊı
  259   3                  str ++;
  260   3              }
  261   2              else if('+' == *str)                                                    // Èç¹ûµÚÒ»¸ö×Ö·ûÊÇÕıºÅ
  262   2              {
  263   3                  str ++;
  264   3              }
  265   2      
  266   2              // ÌáÈ¡ÕûÊı²¿·Ö
  267   2              while(('0' <= *str) && ('9' >= *str))                                   // È·¶¨ÕâÊÇ¸öÊı×Ö
  268   2              {
  269   3                  temp = temp * 10 + ((uint8)(*str) - 0x30);                          // ½«ÊıÖµÌáÈ¡³öÀ´
  270   3                  str ++;
  271   3              }
  272   2              if('.' == *str)
  273   2              {
  274   3                  str ++;
  275   3                  while(('0' <= *str) && ('9' >= *str) && point_bit < 1000000.0)      // È·ÈÏÕâÊÇ¸öÊı×Ö ²¢ÇÒ¾«¶
             -È¿ØÖÆ»¹Ã»µ½ÁùÎ»
  276   3                  {
  277   4                      temp_point = temp_point * 10 + ((uint8)(*str) - 0x30);          // ÌáÈ¡Ğ¡Êı²¿·ÖÊıÖµ
  278   4                      point_bit *= 10;                                                // ¼ÆËãÕâ²¿·ÖĞ¡ÊıµÄ³ıÊı
  279   4                      str ++;
  280   4                  }
  281   3                  temp_point /= point_bit;                                            // ¼ÆËãĞ¡Êı
  282   3              }
  283   2              temp += temp_point;                                                     // ½«ÊıÖµÆ´ºÏ
  284   2      
  285   2              if(sign)
  286   2              {
  287   3                  temp = -temp;
  288   3              }
  289   2          }while(0);
  290   1          return temp;
  291   1      }
  292          
  293          //-------------------------------------------------------------------------------------------------------
             -------------
  294          // º¯Êı¼ò½é     ¸¡µãÊı×Ö×ª×Ö·û´®
  295          // ²ÎÊıËµÃ÷     *str            ×Ö·û´®Ö¸Õë
  296          // ²ÎÊıËµÃ÷     number          ´«ÈëµÄÊı¾İ
  297          // ²ÎÊıËµÃ÷     point_bit       Ğ¡Êıµã¾«¶È
C251 COMPILER V5.60.0,  SEEKFREE_FUNCTION                                                  15/07/24  23:30:46  PAGE 6   

  298          // ·µ»Ø²ÎÊı     void
  299          // Ê¹ÓÃÊ¾Àı     func_float_to_str(data_buffer, 3.1415, 2);                      // ½á¹ûÊä³ö data_buffer =
             - "3.14"
  300          // ±¸×¢ĞÅÏ¢     
  301          //-------------------------------------------------------------------------------------------------------
             -------------
  302          void func_float_to_str (char *str, float number, uint8 point_bit)
  303          {
  304   1      
  305   1          int data_int = 0;                                                           // ÕûÊı²¿·Ö
  306   1          int data_float = 0.0;                                                       // Ğ¡Êı²¿·Ö
  307   1          int data_temp[8];                                                           // ÕûÊı×Ö·û»º³å
  308   1          int data_temp_point[6];                                                     // Ğ¡Êı×Ö·û»º³å
  309   1          uint8 dat_bit = point_bit;                                                      // ×ª»»¾«¶ÈÎ»Êı
  310   1      
  311   1          do
  312   1          {
  313   2              if(NULL == str)
  314   2              {
  315   3                  break;
  316   3              }
  317   2      
  318   2              // ÌáÈ¡ÕûÊı²¿·Ö
  319   2              data_int = (int)number;                                                 // Ö±½ÓÇ¿ÖÆ×ª»»Îª int
  320   2              if(0 > number)                                                          // ÅĞ¶ÏÔ´Êı¾İÊÇÕıÊı»¹ÊÇ¸º
             -Êı
  321   2              {
  322   3                  *str ++ = '-';
  323   3              }
  324   2              else if(0.0 == number)                                                  // Èç¹ûÊÇ¸ö 0
  325   2              {
  326   3                  *str ++ = '0';
  327   3                  *str ++ = '.';
  328   3                  *str = '0';
  329   3                  break;
  330   3              }
  331   2      
  332   2              // ÌáÈ¡Ğ¡Êı²¿·Ö
  333   2              number = number - data_int;                                             // ¼õÈ¥ÕûÊı²¿·Ö¼´¿É
  334   2              while(dat_bit --)
  335   2              {
  336   3                  number = number * 10;                                               // ½«ĞèÒªµÄĞ¡ÊıÎ»ÊıÌáÈ¡µ½
             -ÕûÊı²¿·Ö
  337   3              }
  338   2              data_float = (int)number;                                               // »ñÈ¡Õâ²¿·ÖÊıÖµ
  339   2      
  340   2              // ÕûÊı²¿·Ö×ªÎª×Ö·û´®
  341   2              dat_bit = 0;
  342   2              do
  343   2              {
  344   3                  data_temp[dat_bit ++] = data_int % 10;                                  // ½«ÕûÊı²¿·Öµ¹ĞòĞ´Èë
             -×Ö·û»º³åÇø
  345   3                  data_int /= 10;
  346   3              }while(0 != data_int);
  347   2              while(0 != dat_bit)
  348   2              {
  349   3                  *str ++ = (func_abs(data_temp[dat_bit - 1]) + 0x30);                    // ÔÙµ¹Ğò½«µ¹ĞòµÄÊıÖµ
             -Ğ´Èë×Ö·û´® µÃµ½ÕıĞòÊıÖµ
  350   3                  dat_bit --;
  351   3              }
  352   2      
  353   2              // Ğ¡Êı²¿·Ö×ªÎª×Ö·û´®
  354   2              if(point_bit != 0)
  355   2              {
  356   3                  dat_bit = 0;
  357   3                  *str ++ = '.';
C251 COMPILER V5.60.0,  SEEKFREE_FUNCTION                                                  15/07/24  23:30:46  PAGE 7   

  358   3                  if(0 == data_float)
  359   3                  {
  360   4                      *str = '0';
  361   4                  }
  362   3                  else
  363   3                  {
  364   4                      while(0 != point_bit)                                           // ÅĞ¶ÏÓĞĞ§Î»Êı
  365   4                      {
  366   5                          data_temp_point[dat_bit ++] = data_float % 10;                  // µ¹ĞòĞ´Èë×Ö·û»º³åÇø
  367   5                          data_float /= 10;
  368   5                          point_bit --;                                                
  369   5                      }
  370   4                      while(0 != dat_bit)
  371   4                      {
  372   5                          *str ++ = (func_abs(data_temp_point[dat_bit - 1]) + 0x30);      // ÔÙµ¹Ğò½«µ¹ĞòµÄÊıÖµ
             -Ğ´Èë×Ö·û´® µÃµ½ÕıĞòÊıÖµ
  373   5                          dat_bit --;
  374   5                      }
  375   4                  }
  376   3              }
  377   2          }while(0);
  378   1      }
  379          
  380          //-------------------------------------------------------------------------------------------------------
             -------------
  381          // º¯Êı¼ò½é     ×Ö·û´®×ª¸¡µãÊı ÓĞĞ§ÀÛ¼Æ¾«¶ÈÎªĞ¡Êıµãºó¾ÅÎ»
  382          // ²ÎÊıËµÃ÷     str             ´«Èë×Ö·û´® ¿É´ø·ûºÅ
  383          // ·µ»Ø²ÎÊı     double          ×ª»»ºóµÄÊı¾İ          
  384          // Ê¹ÓÃÊ¾Àı     double dat = func_str_to_double("-100.2");
  385          // ±¸×¢ĞÅÏ¢     
  386          //-------------------------------------------------------------------------------------------------------
             -------------
  387          double func_str_to_double (char *str)
  388          {
  389   1      
  390   1          uint8 sign = 0;                                                             // ±ê¼Ç·ûºÅ 0-ÕıÊı 1-¸ºÊı
  391   1          double temp = 0.0;                                                          // ÁÙÊ±¼ÆËã±äÁ¿ ÕûÊı²¿·Ö
  392   1          double temp_point = 0.0;                                                    // ÁÙÊ±¼ÆËã±äÁ¿ Ğ¡Êı²¿·Ö
  393   1          double point_bit = 1;                                                       // Ğ¡ÊıÀÛ¼Æ³ıÊı
  394   1      
  395   1          do
  396   1          {
  397   2              if(NULL == str)
  398   2              {
  399   3                  break;
  400   3              }
  401   2      
  402   2              if('-' == *str)                                                         // ¸ºÊı
  403   2              {
  404   3                  sign = 1;                                                           // ±ê¼Ç¸ºÊı
  405   3                  str ++;
  406   3              }
  407   2              else if('+' == *str)                                                    // Èç¹ûµÚÒ»¸ö×Ö·ûÊÇÕıºÅ
  408   2              {
  409   3                  str ++;
  410   3              }
  411   2      
  412   2              // ÌáÈ¡ÕûÊı²¿·Ö
  413   2              while(('0' <= *str) && ('9' >= *str))                                   // È·¶¨ÕâÊÇ¸öÊı×Ö
  414   2              {
  415   3                  temp = temp * 10 + ((uint8)(*str) - 0x30);                          // ½«ÊıÖµÌáÈ¡³öÀ´
  416   3                  str ++;
  417   3              }
  418   2              if('.' == *str)
  419   2              {
  420   3                  str ++;
C251 COMPILER V5.60.0,  SEEKFREE_FUNCTION                                                  15/07/24  23:30:46  PAGE 8   

  421   3                  while(('0' <= *str) && ('9' >= *str) && point_bit < 1000000000.0)   // È·ÈÏÕâÊÇ¸öÊı×Ö ²¢ÇÒ¾«¶
             -È¿ØÖÆ»¹Ã»µ½¾ÅÎ»
  422   3                  {
  423   4                      temp_point = temp_point * 10 + ((uint8)(*str) - 0x30);          // ÌáÈ¡Ğ¡Êı²¿·ÖÊıÖµ
  424   4                      point_bit *= 10;                                                // ¼ÆËãÕâ²¿·ÖĞ¡ÊıµÄ³ıÊı
  425   4                      str ++;
  426   4                  }
  427   3                  temp_point /= point_bit;                                            // ¼ÆËãĞ¡Êı
  428   3              }
  429   2              temp += temp_point;                                                     // ½«ÊıÖµÆ´ºÏ
  430   2      
  431   2              if(sign)
  432   2              {
  433   3                  temp = -temp;
  434   3              }
  435   2          }while(0);
  436   1          return temp;
  437   1      
  438   1      }
  439          
  440          //-------------------------------------------------------------------------------------------------------
             -------------
  441          // º¯Êı¼ò½é     ¸¡µãÊı×Ö×ª×Ö·û´®
  442          // ²ÎÊıËµÃ÷     *str            ×Ö·û´®Ö¸Õë
  443          // ²ÎÊıËµÃ÷     number          ´«ÈëµÄÊı¾İ
  444          // ²ÎÊıËµÃ÷     point_bit       Ğ¡Êıµã¾«¶È
  445          // ·µ»Ø²ÎÊı     void
  446          // Ê¹ÓÃÊ¾Àı     func_double_to_str(data_buffer, 3.1415, 2);                     // ½á¹ûÊä³ö data_buffer =
             - "3.14"
  447          // ±¸×¢ĞÅÏ¢     
  448          //-------------------------------------------------------------------------------------------------------
             -------------
  449          void func_double_to_str (char *str, double number, uint8 point_bit)
  450          {
  451   1      
  452   1          int data_int = 0;                                                           // ÕûÊı²¿·Ö
  453   1          int data_float = 0.0;                                                       // Ğ¡Êı²¿·Ö
  454   1          int data_temp[12];                                                          // ÕûÊı×Ö·û»º³å
  455   1          int data_temp_point[9];                                                     // Ğ¡Êı×Ö·û»º³å
  456   1          uint8 dat_bit = point_bit;                                                      // ×ª»»¾«¶ÈÎ»Êı
  457   1      
  458   1          do
  459   1          {
  460   2              if(NULL == str)
  461   2              {
  462   3                  break;
  463   3              }
  464   2      
  465   2              // ÌáÈ¡ÕûÊı²¿·Ö
  466   2              data_int = (int)number;                                                 // Ö±½ÓÇ¿ÖÆ×ª»»Îª int
  467   2              if(0 > number)                                                          // ÅĞ¶ÏÔ´Êı¾İÊÇÕıÊı»¹ÊÇ¸º
             -Êı
  468   2              {
  469   3                  *str ++ = '-';
  470   3              }
  471   2              else if(0.0 == number)                                                  // Èç¹ûÊÇ¸ö 0
  472   2              {
  473   3                  *str ++ = '0';
  474   3                  *str ++ = '.';
  475   3                  *str = '0';
  476   3                  break;
  477   3              }
  478   2      
  479   2              // ÌáÈ¡Ğ¡Êı²¿·Ö
  480   2              number = number - data_int;                                             // ¼õÈ¥ÕûÊı²¿·Ö¼´¿É
  481   2              while(dat_bit --)
C251 COMPILER V5.60.0,  SEEKFREE_FUNCTION                                                  15/07/24  23:30:46  PAGE 9   

  482   2              {
  483   3                  number = number * 10;                                               // ½«ĞèÒªµÄĞ¡ÊıÎ»ÊıÌáÈ¡µ½
             -ÕûÊı²¿·Ö
  484   3              }
  485   2              data_float = (int)number;                                               // »ñÈ¡Õâ²¿·ÖÊıÖµ
  486   2      
  487   2              // ÕûÊı²¿·Ö×ªÎª×Ö·û´®
  488   2              dat_bit = 0;
  489   2              do
  490   2              {
  491   3                  data_temp[dat_bit ++] = data_int % 10;                                  // ½«ÕûÊı²¿·Öµ¹ĞòĞ´Èë
             -×Ö·û»º³åÇø
  492   3                  data_int /= 10;
  493   3              }while(0 != data_int);
  494   2              while(0 != dat_bit )
  495   2              {
  496   3                  *str ++ = (func_abs(data_temp[dat_bit - 1]) + 0x30);                    // ÔÙµ¹Ğò½«µ¹ĞòµÄÊıÖµ
             -Ğ´Èë×Ö·û´® µÃµ½ÕıĞòÊıÖµ
  497   3                  dat_bit --;
  498   3              }
  499   2      
  500   2              // Ğ¡Êı²¿·Ö×ªÎª×Ö·û´®
  501   2              if(point_bit != 0)
  502   2              {
  503   3                  dat_bit = 0;
  504   3                  *str ++ = '.';
  505   3                  if(0 == data_float)
  506   3                      *str = '0';
  507   3                  else
  508   3                  {
  509   4                      while(0 != point_bit)                                           // ÅĞ¶ÏÓĞĞ§Î»Êı
  510   4                      {
  511   5                          data_temp_point[dat_bit ++] = data_float % 10;                  // µ¹ĞòĞ´Èë×Ö·û»º³åÇø
  512   5                          data_float /= 10;
  513   5                          point_bit --;                                                
  514   5                      }
  515   4                      while(0 != dat_bit )
  516   4                      {
  517   5                          *str ++ = (func_abs(data_temp_point[dat_bit - 1]) + 0x30);      // ÔÙµ¹Ğò½«µ¹ĞòµÄÊıÖµ
             -Ğ´Èë×Ö·û´® µÃµ½ÕıĞòÊıÖµ
  518   5                          dat_bit --;
  519   5                      }
  520   4                  }
  521   3              }
  522   2          }while(0);
  523   1      }
  524          
  525          //-------------------------------------------------------------------------------------------------------
             -------------
  526          // º¯Êı¼ò½é     ×Ö·û´®×ª Hex
  527          // ²ÎÊıËµÃ÷     str             ´«Èë×Ö·û´® ÎŞ·ûºÅ
  528          // ·µ»Ø²ÎÊı     uint32          ×ª»»ºóµÄÊı¾İ
  529          // Ê¹ÓÃÊ¾Àı     uint32 dat = func_str_to_hex("0x11");
  530          // ±¸×¢ĞÅÏ¢     
  531          //-------------------------------------------------------------------------------------------------------
             -------------
  532          uint32 func_str_to_hex (char *str)
  533          {
  534   1      
  535   1          uint32 str_len = strlen(str);                                               // ×Ö·û´®³¤
  536   1          uint32 result_data = 0;                                                     // ½á¹û»º´æ
  537   1          uint8 temp = 0;                                                             // ¼ÆËã±äÁ¿
  538   1          uint8 flag = 0;                                                             // ±êÖ¾Î»
  539   1      
  540   1          do
  541   1          {
C251 COMPILER V5.60.0,  SEEKFREE_FUNCTION                                                  15/07/24  23:30:46  PAGE 10  

  542   2              if(NULL == str)
  543   2              {
  544   3                  break;
  545   3              }
  546   2      
  547   2              if(flag)
  548   2              {
  549   3                  if(('a' <= *str) && ('f' >= *str))
  550   3                  {
  551   4                      temp = (*str - 87);
  552   4                  }
  553   3                  else if(('A' <= *str) && ('F' >= *str))
  554   3                  {
  555   4                      temp = (*str - 55);
  556   4                  }
  557   3                  else if(('0' <= *str) && ('9' >= *str))
  558   3                  {
  559   4                      temp = (*str - 48);
  560   4                  }
  561   3                  else
  562   3                  {
  563   4                      break;
  564   4                  }
  565   3                  result_data = ((result_data << 4) | (temp & 0x0F));
  566   3              }
  567   2              else
  568   2              {
  569   3      //            if(strncmp("0x", str, 2))
  570   3                  if((*str == '0') && (*(str + 1) == 'x'))
  571   3                  {
  572   4                      str ++;
  573   4                      flag = 1;
  574   4                  }
  575   3              }
  576   2              str ++;
  577   2          }while(str_len --);
  578   1      
  579   1          return result_data;
  580   1      }
  581          
  582          //-------------------------------------------------------------------------------------------------------
             -------------
  583          // º¯Êı¼ò½é     Hex ×ª×Ö·û´®
  584          // ²ÎÊıËµÃ÷     *str            ×Ö·û´®Ö¸Õë
  585          // ²ÎÊıËµÃ÷     number          ´«ÈëµÄÊı¾İ
  586          // ·µ»Ø²ÎÊı     void
  587          // Ê¹ÓÃÊ¾Àı     func_hex_to_str(data_buffer, 0x11);                             // ½á¹ûÊä³ö data_buffer =
             - "0x11"
  588          // ±¸×¢ĞÅÏ¢     
  589          //-------------------------------------------------------------------------------------------------------
             -------------
  590          void func_hex_to_str (char *str, uint32 number)
  591          {
  592   1      
  593   1          const char hex_index[16] = {
  594   1              '0', '1', '2', '3',
  595   1              '4', '5', '6', '7',
  596   1              '8', '9', 'A', 'B',
  597   1              'C', 'D', 'E', 'F'};
  598   1          int8 data_temp[12];                                                         // »º³åÇø
  599   1          uint8 dat_bit = 0;                                                              // Êı×ÖÎ»Êı
  600   1      
  601   1          *str++ = '0';
  602   1          *str++ = 'x';
  603   1          do
  604   1          {
C251 COMPILER V5.60.0,  SEEKFREE_FUNCTION                                                  15/07/24  23:30:46  PAGE 11  

  605   2              if(NULL == str)
  606   2              {
  607   3                  break;
  608   3              }
  609   2      
  610   2              if(0 == number)                                                         // ÕâÊÇ¸ö 0
  611   2              {
  612   3                  *str = '0';
  613   3                  break;
  614   3              }
  615   2      
  616   2              while(0 != number)                                                      // Ñ­»·Ö±µ½ÊıÖµ¹éÁã
  617   2              {
  618   3                  data_temp[dat_bit ++] = (number & 0xF);                                 // µ¹Ğò½«ÊıÖµÌáÈ¡³öÀ´
  619   3                  number >>= 4;                                                       // Ï÷¼õ±»ÌáÈ¡µÄ¸öÎ»Êı
  620   3              }
  621   2              while(0 != dat_bit)                                                         // ÌáÈ¡µÄÊı×Ö¸öÊıµİ¼õ
             -´¦Àí
  622   2              {
  623   3                  *str ++ = hex_index[data_temp[dat_bit - 1]];                            // ½«Êı×Ö´Óµ¹ĞòÊı×éÖĞ
             -µ¹ĞòÈ¡³ö ±ä³ÉÕıĞò·ÅÈë×Ö·û´®
  624   3                  dat_bit --;
  625   3              }
  626   2          }while(0);
  627   1      }
  628          
  629          //-------------------------------------------------------------------------------------------------------
             -------------
  630          // º¯Êı¼ò½é     Êı×Ö×ª»»Îª ASCII Öµ
  631          // ²ÎÊıËµÃ÷     dat             ´«ÈëµÄÊı¾İ
  632          // ²ÎÊıËµÃ÷     *p              Êı¾İ»º³å
  633          // ²ÎÊıËµÃ÷     neg_type        Êı¾İÀàĞÍ
  634          // ²ÎÊıËµÃ÷     radix           ½øÖÆ
  635          // ·µ»Ø²ÎÊı     uint8           Êı¾İ
  636          // Ê¹ÓÃÊ¾Àı     number_conversion_ascii((uint32)ival, vstr, 1, 10);
  637          // ±¸×¢ĞÅÏ¢     ±¾º¯ÊıÔÚÎÄ¼şÄÚ²¿µ÷ÓÃ ÓÃ»§²»ÓÃ¹Ø×¢ Ò²²»¿ÉĞŞ¸Ä
  638          //-------------------------------------------------------------------------------------------------------
             -------------
  639          static uint8 number_conversion_ascii (uint32 dat, int8 *p, uint8 neg_type, uint8 radix)
  640          {
  641   1          int32   neg_dat;
  642   1          uint32  pos_dat;
  643   1          uint8   temp_data = 0;
  644   1          uint8   valid_num = 0;
  645   1      
  646   1          if(neg_type)
  647   1          {
  648   2              neg_dat = (int32)dat;
  649   2              if(0 > neg_dat)
  650   2              {
  651   3                  neg_dat = -neg_dat;
  652   3              }
  653   2              while(1)
  654   2              {
  655   3                  *p = neg_dat%radix + '0';
  656   3                  neg_dat = neg_dat/radix;
  657   3                  valid_num ++;
  658   3      
  659   3                  if(!neg_dat)
  660   3                  {
  661   4                      break;
  662   4                  }
  663   3                  p ++;
  664   3              }
  665   2          }
  666   1          else
C251 COMPILER V5.60.0,  SEEKFREE_FUNCTION                                                  15/07/24  23:30:46  PAGE 12  

  667   1          {
  668   2              pos_dat = dat;
  669   2              while(1)
  670   2              {
  671   3                  temp_data = pos_dat%radix;
  672   3                  if(10 <= temp_data)
  673   3                  {
  674   4                      temp_data += 'A'-10;
  675   4                  }
  676   3                  else
  677   3                  {
  678   4                      temp_data += '0';
  679   4                  }
  680   3      
  681   3                  *p = temp_data;
  682   3      
  683   3                  pos_dat = pos_dat/radix;
  684   3                  valid_num ++;
  685   3      
  686   3                  if(!pos_dat)
  687   3                  {
  688   4                      break;
  689   4                  }
  690   3                  p ++;
  691   3              }
  692   2          }
  693   1          return valid_num;
  694   1      }
  695          
  696          //-------------------------------------------------------------------------------------------------------
             -------------
  697          // º¯Êı¼ò½é     printf ÏÔÊ¾×ª»»
  698          // ²ÎÊıËµÃ÷     *d_buff         »º³åÇø
  699          // ²ÎÊıËµÃ÷     len             ³¤¶È
  700          // ·µ»Ø²ÎÊı     void
  701          // Ê¹ÓÃÊ¾Àı     printf_reverse_order(vstr, vlen);
  702          // ±¸×¢ĞÅÏ¢     ±¾º¯ÊıÔÚÎÄ¼şÄÚ²¿µ÷ÓÃ ÓÃ»§²»ÓÃ¹Ø×¢ Ò²²»¿ÉĞŞ¸Ä
  703          //-------------------------------------------------------------------------------------------------------
             -------------
  704          static void printf_reverse_order (int8 *d_buff, uint32 len)
  705          {
  706   1          uint32 i;
  707   1          int8  temp_data;
  708   1          for(i = 0; len / 2 > i; i ++)
  709   1          {
  710   2              temp_data = d_buff[len - 1 - i];
  711   2              d_buff[len - 1 -i ] = d_buff[i];
  712   2              d_buff[i] = temp_data; 
  713   2          }
  714   1      }
  715          
  716          //-------------------------------------------------------------------------------------------------------
             -------------
  717          // º¯Êı¼ò½é     sprintf º¯ÊıÊµÏÖ
  718          // ²ÎÊıËµÃ÷     *buff           »º³åÇø
  719          // ²ÎÊıËµÃ÷     *format         Ô´×Ö·û´®
  720          // ²ÎÊıËµÃ÷     ...             ¿É±ä²ÎÊıÁĞ±í
  721          // ·µ»Ø²ÎÊı     uint32          ´¦ÀíºóÊı¾İ³¤
  722          // Ê¹ÓÃÊ¾Àı     zf_sprintf(buff, "Data : %d", 100);
  723          // ±¸×¢ĞÅÏ¢     ±¾º¯ÊıÔÚÎÄ¼şÄÚ²¿µ÷ÓÃ ÓÃ»§²»ÓÃ¹Ø×¢ Ò²²»¿ÉĞŞ¸Ä
  724          //-------------------------------------------------------------------------------------------------------
             -------------
  725          uint32 zf_sprintf(char  *buff, const int8 *format, ...)
  726          {
  727   1          uint32 buff_len=0;
  728   1          va_list arg;
C251 COMPILER V5.60.0,  SEEKFREE_FUNCTION                                                  15/07/24  23:30:46  PAGE 13  

  729   1        va_start(arg, format);
  730   1       
  731   1        while (*format)
  732   1        {
  733   2          int8 ret = *format;
  734   2          if (ret == '%')
  735   2          {
  736   3            switch (*++format)
  737   3            {
  738   4                      case 'a':// Ê®Áù½øÖÆp¼ÆÊı·¨Êä³ö¸¡µãÊı ÔİÎ´ÊµÏÖ
  739   4                      {
  740   5                          
  741   5                          
  742   5                      }break;
  743   4                      
  744   4                      
  745   4                      case 'c':// Ò»¸ö×Ö·û
  746   4                      {
  747   5                          int8 ch = (int8)va_arg(arg, uint32);
  748   5                          *buff = ch;
  749   5                          buff++;
  750   5                          buff_len++;
  751   5                                  
  752   5                      }break;
  753   4                      
  754   4                      
  755   4                      case 'd':
  756   4                      case 'i':// ÓĞ·ûºÅÊ®½øÖÆÕûÊı
  757   4                      {
  758   5                          int8 vstr[33];
  759   5                          int32 ival = (int32)va_arg(arg, int32);
  760   5                          uint8 vlen = number_conversion_ascii((uint32)ival, vstr, 1, 10);
  761   5                          
  762   5                          if(ival<0)  
  763   5                          {
  764   6                              vstr[vlen] = '-';
  765   6                              vlen++;
  766   6                          }
  767   5                          printf_reverse_order(vstr,vlen);
  768   5                          memcpy(buff,vstr,vlen);
  769   5                          buff += vlen;
  770   5                          buff_len += vlen;
  771   5                          
  772   5                          
  773   5                      }break;
  774   4                      
  775   4                      case 'f':// ¸¡µãÊı£¬Êä³öĞ¡ÊıµãºóÁùÎ»  ²»ÄÜÖ¸¶¨Êä³ö¾«¶È
  776   4                      case 'F':// ¸¡µãÊı£¬Êä³öĞ¡ÊıµãºóÁùÎ»  ²»ÄÜÖ¸¶¨Êä³ö¾«¶È
  777   4                      {
  778   5                          int8 vstr[33];
  779   5                          double ival = (double)va_arg(arg, double);
  780   5                          uint8 vlen = number_conversion_ascii((uint32)(int32)ival, vstr, 1, 10);
  781   5                          
  782   5                          if(ival<0)  
  783   5                          {
  784   6                              vstr[vlen] = '-';
  785   6                              vlen++;
  786   6                          }
  787   5                          printf_reverse_order(vstr,vlen);
  788   5                          memcpy(buff,vstr,vlen);
  789   5                          buff += vlen;
  790   5                          buff_len += vlen;
  791   5      
  792   5                          ival = ((double)ival - (int32)ival)*1000000;
  793   5                          if(ival)
  794   5                          {
C251 COMPILER V5.60.0,  SEEKFREE_FUNCTION                                                  15/07/24  23:30:46  PAGE 14  

  795   6                              vlen = number_conversion_ascii((uint32)(int32)ival, vstr, 1, 10);
  796   6                          }
  797   5                          else
  798   5                          {
  799   6                              vstr[0] = vstr[1] = vstr[2] = vstr[3] = vstr[4] = vstr[5] = '0';
  800   6                              vlen = 6;
  801   6                          }
  802   5                
  803   5                          while(6>vlen)
  804   5                          {
  805   6                              vstr[vlen] = '0';
  806   6                              vlen++;
  807   6                          }
  808   5                
  809   5                          vstr[vlen] = '.';
  810   5                          vlen++;
  811   5                          
  812   5                          printf_reverse_order(vstr,vlen);
  813   5                          memcpy(buff,vstr,vlen);
  814   5                buff += vlen;
  815   5                          buff_len += vlen;
  816   5      
  817   5                          break;
  818   5                      }
  819   4                      
  820   4                      case 'u':// ÎŞ·ûºÅÊ®½øÖÆÕûÊı
  821   4                      {
  822   5                          int8 vstr[33];
  823   5                          uint32 ival = (uint32)va_arg(arg, uint32);
  824   5                          uint8 vlen = number_conversion_ascii(ival, vstr, 0, 10);
  825   5                          
  826   5                          printf_reverse_order(vstr,vlen);
  827   5                          memcpy(buff,vstr,vlen);
  828   5                          buff += vlen;
  829   5                          buff_len += vlen;
  830   5                      }break;
  831   4                      
  832   4                      case 'o':// ÎŞ·ûºÅ°Ë½øÖÆÕûÊı 
  833   4                      {
  834   5                          int8 vstr[33];
  835   5                          uint32 ival = (uint32)va_arg(arg, uint32);
  836   5                          uint8 vlen = number_conversion_ascii(ival, vstr, 0, 8);
  837   5                          
  838   5                          printf_reverse_order(vstr,vlen);
  839   5                          memcpy(buff,vstr,vlen);
  840   5                          buff += vlen;
  841   5                          buff_len += vlen;
  842   5                          
  843   5                      }break;
  844   4                      
  845   4                      case 'x':// ÎŞ·ûºÅÊ®Áù½øÖÆÕûÊı
  846   4                      case 'X':// ÎŞ·ûºÅÊ®Áù½øÖÆÕûÊı
  847   4                      {
  848   5                          int8 vstr[33];
  849   5                          uint32 ival = (uint32)va_arg(arg, uint32);
  850   5                          uint8 vlen = number_conversion_ascii(ival, vstr, 0, 16);
  851   5                          
  852   5                          printf_reverse_order(vstr,vlen);
  853   5                          memcpy(buff,vstr,vlen);
  854   5                          buff += vlen;
  855   5                          buff_len += vlen;
  856   5                      }break;
  857   4                      
  858   4                      
  859   4                      case 's':// ×Ö·û´®
  860   4                      {
C251 COMPILER V5.60.0,  SEEKFREE_FUNCTION                                                  15/07/24  23:30:46  PAGE 15  

  861   5                          int8 *pc = va_arg(arg, int8 *);
  862   5                          while (*pc)
  863   5                          {
  864   6                              *buff = *pc;
  865   6                              buff++;
  866   6                              buff_len++;
  867   6                              pc++;
  868   6                          }
  869   5                      }break;
  870   4                      
  871   4                      case 'p':// ÒÔ16½øÖÆĞÎÊ½Êä³öÖ¸Õë
  872   4                      {
  873   5                          int8 vstr[33];
  874   5                          uint32 ival = (uint32)va_arg(arg, uint32);
  875   5                          //uint8 vlen = number_conversion_ascii(ival, vstr, 0, 16);
  876   5                number_conversion_ascii(ival, vstr, 0, 16);
  877   5                          
  878   5                          printf_reverse_order(vstr,8);
  879   5                          memcpy(buff,vstr,8);
  880   5                          buff += 8;
  881   5                          buff_len += 8;
  882   5                                  
  883   5                      }break;
  884   4                      
  885   4                      
  886   4                      case '%':// Êä³ö×Ö·û% 
  887   4                      {
  888   5                          *buff = '%';
  889   5                          buff++;
  890   5                          buff_len++;
  891   5                      }break;
  892   4      
  893   4                      default:break;
  894   4            }
  895   3          }
  896   2          else
  897   2          {
  898   3                  *buff = (int8)(*format);
  899   3                  buff++;
  900   3                  buff_len++;
  901   3          }
  902   2          format++;
  903   2        }
  904   1        va_end(arg);
  905   1      
  906   1          return buff_len;
  907   1      }
  908          
  909          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      5450     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       394     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
C251 COMPILER V5.60.0,  SEEKFREE_FUNCTION                                                  15/07/24  23:30:46  PAGE 16  

  const size           =    ------     ------
  hconst size          =        16     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
